{"version":3,"file":"gw-text.min.js","sources":["../js/config.js","../js/compile.js","../js/utils.js","../js/lines.js","../js/each.js","../js/index.js"],"sourcesContent":["export var options = {\n    colorStart: 'Ω',\n    colorEnd: '∆',\n    field: '§',\n    defaultFg: null,\n    defaultBg: null,\n};\n// const RE_RGB = /^[a-fA-F0-9]*$/;\n// \n// export function parseColor(color:string) {\n//   if (color.startsWith('#')) {\n//     color = color.substring(1);\n//   }\n//   else if (color.startsWith('0x')) {\n//     color = color.substring(2);\n//   }\n//   if (color.length == 3) {\n//     if (RE_RGB.test(color)) {\n//       return Number.parseInt(color, 16);\n//     }\n//   }\n//   if (color.length == 6) {\n//     if (RE_RGB.test(color)) {\n//       const v = Number.parseInt(color, 16);\n//       const r = Math.round( ((v & 0xFF0000) >> 16) / 17);\n//       const g = Math.round( ((v & 0xFF00) >> 8) / 17);\n//       const b = Math.round((v & 0xFF) / 17);\n//       return (r << 8) + (g << 4) + b;\n//     }\n//   }\n//   return 0xFFF;\n// }\nexport var helpers = {\n    eachColor: (() => { }),\n};\nexport function addHelper(name, fn) {\n    helpers[name] = fn;\n}\n","import * as Config from './config';\nexport function compile(template) {\n    const F = Config.options.field;\n    const parts = template.split(F);\n    const sections = parts.map((part, i) => {\n        if (i % 2 == 0)\n            return textSegment(part);\n        if (part.length == 0)\n            return textSegment(F);\n        return makeVariable(part);\n    });\n    return function (args = {}) {\n        return sections.map((f) => f(args)).join('');\n    };\n}\nexport function textSegment(value) {\n    return (() => value);\n}\nexport function baseValue(name) {\n    return function (args) { return args[name] || `!!${name}!!`; };\n}\nexport function fieldValue(name, source) {\n    return function (args) {\n        const obj = source(args);\n        if (!obj)\n            return `!!null.${name}!!`;\n        const value = obj[name];\n        if (value === undefined)\n            return `!!${'' + obj}.${name}!!`;\n        return value;\n    };\n}\nexport function helperValue(name, source) {\n    const helper = Config.helpers[name];\n    if (!helper) {\n        return (() => `Missing Helper:${name}`);\n    }\n    if (!source) {\n        return function (args) {\n            return helper(name, args, undefined);\n        };\n    }\n    return function (args) {\n        const base = source(args);\n        return helper(name, args, base);\n    };\n}\nexport function stringFormat(format, source) {\n    const data = /%(-?\\d*)s/.exec(format) || [];\n    const length = Number.parseInt(data[1] || '0');\n    return function (args) {\n        let text = '' + source(args);\n        if (length < 0) {\n            text = text.padEnd(-length);\n        }\n        else if (length) {\n            text = text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function intFormat(format, source) {\n    const data = /%([\\+-]*)(\\d*)d/.exec(format) || [];\n    let length = Number.parseInt(data[2] || '0');\n    const wantSign = data[1].includes('+');\n    const left = data[1].includes('-');\n    return function (args) {\n        const value = Number.parseInt(source(args) || 0);\n        let text = '' + value;\n        if (value > 0 && wantSign) {\n            text = '+' + text;\n        }\n        if (length && left) {\n            return text.padEnd(length);\n        }\n        else if (length) {\n            return text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function floatFormat(format, source) {\n    const data = /%([\\+-]*)(\\d*)(\\.(\\d+))?f/.exec(format) || [];\n    let length = Number.parseInt(data[2] || '0');\n    const wantSign = data[1].includes('+');\n    const left = data[1].includes('-');\n    const fixed = Number.parseInt(data[4]) || 0;\n    return function (args) {\n        const value = Number.parseFloat(source(args) || 0);\n        let text;\n        if (fixed) {\n            text = value.toFixed(fixed);\n        }\n        else {\n            text = '' + value;\n        }\n        if (value > 0 && wantSign) {\n            text = '+' + text;\n        }\n        if (length && left) {\n            return text.padEnd(length);\n        }\n        else if (length) {\n            return text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function makeVariable(pattern) {\n    const data = /((\\w+) )?(\\w+)(\\.(\\w+))?(%[\\+\\.\\-\\d]*[dsf])?/.exec(pattern) || [];\n    const helper = data[2];\n    const base = data[3];\n    const field = data[5];\n    const format = data[6];\n    let result = baseValue(base);\n    if (field && field.length) {\n        result = fieldValue(field, result);\n    }\n    if (helper && helper.length) {\n        result = helperValue(helper, result);\n    }\n    if (format && format.length) {\n        if (format.endsWith('s')) {\n            result = stringFormat(format, result);\n        }\n        else if (format.endsWith('d')) {\n            result = intFormat(format, result);\n        }\n        else if (format.endsWith('f')) {\n            result = floatFormat(format, result);\n        }\n    }\n    return result;\n}\n","import * as Config from './config';\nexport function length(text) {\n    let len = 0;\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    for (let i = 0; i < text.length; ++i) {\n        const ch = text[i];\n        if (ch == CS) {\n            const end = text.indexOf(CS, i + 1);\n            i = end;\n        }\n        else if (ch == CE) {\n            // skip\n        }\n        else {\n            ++len;\n        }\n    }\n    return len;\n}\nexport function advanceChars(text, start, count) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = start;\n    while (count > 0) {\n        const ch = text[i];\n        if (ch === CS) {\n            ++i;\n            while (text[i] !== CS)\n                ++i;\n            ++i;\n        }\n        else if (ch === CE) {\n            if (text[i + 1] === CE) {\n                --count;\n                ++i;\n            }\n            ++i;\n        }\n        else {\n            --count;\n            ++i;\n        }\n    }\n    return i;\n}\nexport function firstChar(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = 0;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch === CS) {\n            if (text[i + 1] === CS)\n                return CS;\n            ++i;\n            while (text[i] !== CS)\n                ++i;\n            ++i;\n        }\n        else if (ch === CE) {\n            if (text[i + 1] === CE)\n                return CE;\n            ++i;\n        }\n        else {\n            return ch;\n        }\n    }\n    return null;\n}\nexport function padStart(text, width, pad = ' ') {\n    const colorLen = text.length - length(text);\n    return text.padStart(width + colorLen, pad);\n}\nexport function padEnd(text, width, pad = ' ') {\n    const colorLen = text.length - length(text);\n    return text.padEnd(width + colorLen, pad);\n}\nexport function center(text, width, pad = ' ') {\n    const rawLen = text.length;\n    const len = length(text);\n    const padLen = width - len;\n    if (padLen <= 0)\n        return text;\n    const left = Math.floor(padLen / 2);\n    return text.padStart(rawLen + left, pad).padEnd(rawLen + padLen, pad);\n}\nexport function capitalize(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = 0;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch == CS) {\n            ++i;\n            while (text[i] != CS && i < text.length) {\n                ++i;\n            }\n            ++i;\n        }\n        else if (ch == CE) {\n            ++i;\n            while (text[i] == CS && i < text.length) {\n                ++i;\n            }\n        }\n        else {\n            return text.substring(0, i) + ch.toUpperCase() + text.substring(i + 1);\n        }\n    }\n    return text;\n}\nexport function removeColors(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let out = '';\n    let start = 0;\n    for (let i = 0; i < text.length; ++i) {\n        const k = text[i];\n        if (k === CS) {\n            if (text[i + 1] == CS) {\n                ++i;\n                continue;\n            }\n            out += text.substring(start, i);\n            ++i;\n            while (text[i] != CS && i < text.length) {\n                ++i;\n            }\n            start = i + 1;\n        }\n        else if (k === CE) {\n            if (text[i + 1] == CE) {\n                ++i;\n                continue;\n            }\n            out += text.substring(start, i);\n            start = i + 1;\n        }\n    }\n    if (start == 0)\n        return text;\n    out += text.substring(start);\n    return out;\n}\n","import * as Config from './config';\nimport * as Utils from './utils';\nexport function nextBreak(text, start) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = start;\n    let l = 0;\n    let count = true;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch == ' ') {\n            while (text[i + 1] == ' ')\n                ++i;\n            return [i, l];\n        }\n        if (ch == '-') {\n            return [i, l];\n        }\n        if (ch == '\\n') {\n            return [i, l];\n        }\n        if (ch == CS) {\n            if (text[i + 1] == CS && count) {\n                l += 1;\n                i += 2;\n                continue;\n            }\n            count = !count;\n            ++i;\n            continue;\n        }\n        else if (ch == CE) {\n            if (text[i + 1] == CE) {\n                l += 1;\n                ++i;\n            }\n            i++;\n            continue;\n        }\n        l += (count ? 1 : 0);\n        ++i;\n    }\n    return [i, l];\n}\nexport function splice(text, start, len, add = '') {\n    return text.substring(0, start) + add + text.substring(start + len);\n}\nexport function hyphenate(text, width, start, end, wordWidth, spaceLeftOnLine) {\n    if (wordWidth + 1 > (width * 2)) {\n        throw new Error('Cannot hyphenate - word length > 2 * width');\n    }\n    if ((spaceLeftOnLine < 4) || (spaceLeftOnLine + width < wordWidth)) {\n        text = splice(text, start - 1, 1, '\\n');\n        spaceLeftOnLine = width;\n    }\n    if (spaceLeftOnLine + width > wordWidth) {\n        // one hyphen...\n        const hyphenAt = Math.min(Math.floor(wordWidth / 2), spaceLeftOnLine - 1);\n        const w = Utils.advanceChars(text, start, hyphenAt);\n        text = splice(text, w, 0, '-\\n');\n        return [text, end + 2];\n    }\n    if (width >= wordWidth) {\n        return [text, end];\n    }\n    const hyphenAt = Math.min(wordWidth, width - 1);\n    const w = Utils.advanceChars(text, start, hyphenAt);\n    text = splice(text, w, 0, '-\\n');\n    return [text, end + 2];\n}\nexport function wordWrap(text, width, indent = 0) {\n    if (!width)\n        throw new Error('Need string and width');\n    if (text.length < width)\n        return text;\n    if (Utils.length(text) < width)\n        return text;\n    if (text.indexOf('\\n') == -1) {\n        return wrapLine(text, width, indent);\n    }\n    const lines = text.split('\\n');\n    const split = lines.map((line, i) => wrapLine(line, width, (i ? indent : 0)));\n    return split.join('\\n');\n}\n// Returns the number of lines, including the newlines already in the text.\n// Puts the output in \"to\" only if we receive a \"to\" -- can make it null and just get a line count.\nfunction wrapLine(text, width, indent = 0) {\n    if (text.length < width)\n        return text;\n    if (Utils.length(text) < width)\n        return text;\n    let spaceLeftOnLine = width;\n    width = width + indent;\n    let printString = text;\n    // Now go through and replace spaces with newlines as needed.\n    // console.log('wordWrap - ', text, width, indent);\n    let removeSpace = true;\n    let i = -1;\n    while (i < printString.length) {\n        // wordWidth counts the word width of the next word without color escapes.\n        // w indicates the position of the space or newline or null terminator that terminates the word.\n        let [w, wordWidth] = nextBreak(printString, i + (removeSpace ? 1 : 0));\n        let hyphen = false;\n        if (printString[w] == '-') {\n            w++;\n            wordWidth++;\n            hyphen = true;\n        }\n        // console.log('- w=%d, width=%d, space=%d, word=%s', w, wordWidth, spaceLeftOnLine, printString.substring(i, w));\n        if (wordWidth > width) {\n            ([printString, w] = hyphenate(printString, width, i + 1, w, wordWidth, spaceLeftOnLine));\n        }\n        else if (wordWidth == spaceLeftOnLine) {\n            const nl = (w < printString.length) ? '\\n' : '';\n            const remove = hyphen ? 0 : 1;\n            printString = splice(printString, w, remove, nl); // [i] = '\\n';\n            w += (1 - remove); // if we change the length we need to advance our pointer\n            spaceLeftOnLine = width;\n        }\n        else if (wordWidth > spaceLeftOnLine) {\n            const remove = removeSpace ? 1 : 0;\n            printString = splice(printString, i, remove, '\\n'); // [i] = '\\n';\n            w += (1 - remove); // if we change the length we need to advance our pointer\n            const extra = hyphen ? 0 : 1;\n            spaceLeftOnLine = width - wordWidth - extra; // line width minus the width of the word we just wrapped and the space\n            //printf(\"\\n\\n%s\", printString);\n        }\n        else {\n            const extra = hyphen ? 0 : 1;\n            spaceLeftOnLine -= (wordWidth + extra);\n        }\n        removeSpace = !hyphen;\n        i = w; // Advance to the terminator that follows the word.\n    }\n    return printString;\n}\n","import * as Config from './config';\nexport function eachChar(text, fn, fg, bg) {\n    const colors = [];\n    const colorFn = Config.helpers.eachColor;\n    const ctx = {\n        fg: (fg === undefined) ? Config.options.defaultFg : fg,\n        bg: (bg === undefined) ? Config.options.defaultBg : bg,\n    };\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    colorFn({ fg, bg });\n    let n = 0;\n    for (let i = 0; i < text.length; ++i) {\n        const ch = text[i];\n        if (ch == CS) {\n            let j = i + 1;\n            while (j < text.length && text[j] != CS) {\n                ++j;\n            }\n            if (j == text.length) {\n                console.warn('Reached end of string while seeking end of color start section.');\n                console.warn('- text:', text);\n                console.warn('- start @:', i);\n                return; // reached end - done (error though)\n            }\n            if (j == i + 1) { // next char\n                ++i; // fall through\n            }\n            else {\n                colors.push([ctx.fg, ctx.bg]);\n                const color = text.substring(i + 1, j);\n                ([ctx.fg, ctx.bg] = color.split('|'));\n                colorFn(ctx);\n                i = j;\n                continue;\n            }\n        }\n        else if (ch == CE) {\n            if (text[i + 1] == CE) {\n                ++i;\n            }\n            else {\n                const c = colors.pop(); // if you pop too many times colors go away\n                [ctx.fg, ctx.bg] = c || [null, null];\n                // colorFn(ctx);\n                continue;\n            }\n        }\n        fn(ch, ctx.fg, ctx.bg, n, i);\n        ++n;\n    }\n}\n","import { compile } from './compile';\nimport { eachChar } from './each';\nimport { length, padStart, padEnd, center, capitalize, removeColors, firstChar } from './utils';\nimport { wordWrap } from './lines';\nimport { addHelper, options } from './config';\nfunction configure(opts = {}) {\n    if (opts.helpers) {\n        Object.entries(opts.helpers).forEach(([name, fn]) => {\n            addHelper(name, fn);\n        });\n    }\n    if (opts.fg) {\n        options.defaultFg = opts.fg;\n    }\n    if (opts.bg) {\n        options.defaultBg = opts.bg;\n    }\n    if (opts.colorStart) {\n        options.colorStart = opts.colorStart;\n    }\n    if (opts.colorEnd) {\n        options.colorEnd = opts.colorEnd;\n    }\n    if (opts.field) {\n        options.field = opts.field;\n    }\n}\nexport { compile, eachChar, length, padStart, padEnd, center, firstChar, capitalize, removeColors, wordWrap, configure, addHelper, options };\n"],"names":["options","colorStart","colorEnd","field","defaultFg","defaultBg","helpers","eachColor","addHelper","name","fn","textSegment","value","length","text","len","CS","Config.options","CE","i","ch","indexOf","advanceChars","start","count","nextBreak","l","splice","add","substring","hyphenate","width","end","wordWidth","spaceLeftOnLine","Error","Utils.advanceChars","Math","min","floor","wrapLine","indent","Utils.length","printString","removeSpace","w","hyphen","remove","template","F","sections","split","map","part","pattern","data","exec","helper","base","format","result","args","source","obj","undefined","fieldValue","Config.helpers","helperValue","endsWith","Number","parseInt","padEnd","padStart","stringFormat","wantSign","includes","left","intFormat","fixed","parseFloat","toFixed","floatFormat","makeVariable","f","join","fg","bg","colors","colorFn","ctx","n","j","console","warn","push","color","c","pop","pad","colorLen","rawLen","padLen","toUpperCase","out","k","line","opts","Object","entries","forEach"],"mappings":"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"}