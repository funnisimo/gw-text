{"version":3,"file":"gw-text.min.js","sources":["../js/config.js","../js/compile.js","../js/utils.js","../js/lines.js","../js/each.js","../js/index.js"],"sourcesContent":["export var options = {\n    colorStart: 'Ω',\n    colorEnd: '∆',\n    field: '§',\n    defaultFg: null,\n    defaultBg: null,\n};\n// const RE_RGB = /^[a-fA-F0-9]*$/;\n// \n// export function parseColor(color:string) {\n//   if (color.startsWith('#')) {\n//     color = color.substring(1);\n//   }\n//   else if (color.startsWith('0x')) {\n//     color = color.substring(2);\n//   }\n//   if (color.length == 3) {\n//     if (RE_RGB.test(color)) {\n//       return Number.parseInt(color, 16);\n//     }\n//   }\n//   if (color.length == 6) {\n//     if (RE_RGB.test(color)) {\n//       const v = Number.parseInt(color, 16);\n//       const r = Math.round( ((v & 0xFF0000) >> 16) / 17);\n//       const g = Math.round( ((v & 0xFF00) >> 8) / 17);\n//       const b = Math.round((v & 0xFF) / 17);\n//       return (r << 8) + (g << 4) + b;\n//     }\n//   }\n//   return 0xFFF;\n// }\nexport var helpers = {\n    eachColor: (() => { }),\n};\nexport function addHelper(name, fn) {\n    helpers[name] = fn;\n}\n","import * as Config from './config';\nexport function compile(template) {\n    const F = Config.options.field;\n    const parts = template.split(F);\n    const sections = parts.map((part, i) => {\n        if (i % 2 == 0)\n            return textSegment(part);\n        if (part.length == 0)\n            return textSegment(F);\n        return makeVariable(part);\n    });\n    return function (args = {}) {\n        return sections.map((f) => f(args)).join('');\n    };\n}\nexport function textSegment(value) {\n    return (() => value);\n}\nexport function baseValue(name) {\n    return function (args) { return args[name] || `!!${name}!!`; };\n}\nexport function fieldValue(name, source) {\n    return function (args) {\n        const obj = source(args);\n        if (!obj)\n            return `!!null.${name}!!`;\n        const value = obj[name];\n        if (value === undefined)\n            return `!!${'' + obj}.${name}!!`;\n        return value;\n    };\n}\nexport function helperValue(name, source) {\n    const helper = Config.helpers[name];\n    if (!helper) {\n        return (() => `Missing Helper:${name}`);\n    }\n    if (!source) {\n        return function (args) {\n            return helper(name, args, undefined);\n        };\n    }\n    return function (args) {\n        const base = source(args);\n        return helper(name, args, base);\n    };\n}\nexport function stringFormat(format, source) {\n    const data = /%(-?\\d*)s/.exec(format) || [];\n    const length = Number.parseInt(data[1] || '0');\n    return function (args) {\n        let text = '' + source(args);\n        if (length < 0) {\n            text = text.padEnd(-length);\n        }\n        else if (length) {\n            text = text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function intFormat(format, source) {\n    const data = /%([\\+-]*)(\\d*)d/.exec(format) || [];\n    let length = Number.parseInt(data[2] || '0');\n    const wantSign = data[1].includes('+');\n    const left = data[1].includes('-');\n    return function (args) {\n        const value = Number.parseInt(source(args) || 0);\n        let text = '' + value;\n        if (value > 0 && wantSign) {\n            text = '+' + text;\n        }\n        if (length && left) {\n            return text.padEnd(length);\n        }\n        else if (length) {\n            return text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function floatFormat(format, source) {\n    const data = /%([\\+-]*)(\\d*)(\\.(\\d+))?f/.exec(format) || [];\n    let length = Number.parseInt(data[2] || '0');\n    const wantSign = data[1].includes('+');\n    const left = data[1].includes('-');\n    const fixed = Number.parseInt(data[4]) || 0;\n    return function (args) {\n        const value = Number.parseFloat(source(args) || 0);\n        let text;\n        if (fixed) {\n            text = value.toFixed(fixed);\n        }\n        else {\n            text = '' + value;\n        }\n        if (value > 0 && wantSign) {\n            text = '+' + text;\n        }\n        if (length && left) {\n            return text.padEnd(length);\n        }\n        else if (length) {\n            return text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function makeVariable(pattern) {\n    const data = /((\\w+) )?(\\w+)(\\.(\\w+))?(%[\\+\\.\\-\\d]*[dsf])?/.exec(pattern) || [];\n    const helper = data[2];\n    const base = data[3];\n    const field = data[5];\n    const format = data[6];\n    let result = baseValue(base);\n    if (field && field.length) {\n        result = fieldValue(field, result);\n    }\n    if (helper && helper.length) {\n        result = helperValue(helper, result);\n    }\n    if (format && format.length) {\n        if (format.endsWith('s')) {\n            result = stringFormat(format, result);\n        }\n        else if (format.endsWith('d')) {\n            result = intFormat(format, result);\n        }\n        else if (format.endsWith('f')) {\n            result = floatFormat(format, result);\n        }\n    }\n    return result;\n}\n","import * as Config from './config';\nexport function length(text) {\n    let len = 0;\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    for (let i = 0; i < text.length; ++i) {\n        const ch = text[i];\n        if (ch == CS) {\n            const end = text.indexOf(CS, i + 1);\n            i = end;\n        }\n        else if (ch == CE) {\n            // skip\n        }\n        else {\n            ++len;\n        }\n    }\n    return len;\n}\nexport function padStart(text, width, pad = ' ') {\n    const colorLen = text.length - length(text);\n    return text.padStart(width + colorLen, pad);\n}\nexport function padEnd(text, width, pad = ' ') {\n    const colorLen = text.length - length(text);\n    return text.padEnd(width + colorLen, pad);\n}\nexport function center(text, width, pad = ' ') {\n    const rawLen = text.length;\n    const len = length(text);\n    const padLen = width - len;\n    if (padLen <= 0)\n        return text;\n    const left = Math.floor(padLen / 2);\n    return text.padStart(rawLen + left, pad).padEnd(rawLen + padLen, pad);\n}\nexport function capitalize(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = 0;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch == CS) {\n            ++i;\n            while (text[i] != CS && i < text.length) {\n                ++i;\n            }\n            ++i;\n        }\n        else if (ch == CE) {\n            ++i;\n            while (text[i] == CS && i < text.length) {\n                ++i;\n            }\n        }\n        else {\n            return text.substring(0, i) + ch.toUpperCase() + text.substring(i + 1);\n        }\n    }\n    return text;\n}\nexport function removeColors(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let out = '';\n    let start = 0;\n    for (let i = 0; i < text.length; ++i) {\n        const k = text[i];\n        if (k === CS) {\n            if (text[i + 1] == CS) {\n                ++i;\n                continue;\n            }\n            out += text.substring(start, i);\n            ++i;\n            while (text[i] != CS && i < text.length) {\n                ++i;\n            }\n            start = i + 1;\n        }\n        else if (k === CE) {\n            if (text[i + 1] == CE) {\n                ++i;\n                continue;\n            }\n            out += text.substring(start, i);\n            start = i + 1;\n        }\n    }\n    if (start == 0)\n        return text;\n    out += text.substring(start);\n    return out;\n}\n","import * as Config from './config';\nimport * as Utils from './utils';\nexport function nextBreak(text, start) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = start;\n    let l = 0;\n    let count = true;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch == ' ') {\n            while (text[i + 1] == ' ')\n                ++i;\n            return [i, l];\n        }\n        if (ch == '-') {\n            return [i, l];\n        }\n        if (ch == '\\n') {\n            return [i, l];\n        }\n        if (ch == CS) {\n            if (text[i + 1] == CS && count) {\n                l += 1;\n                i += 2;\n                continue;\n            }\n            count = !count;\n            ++i;\n            continue;\n        }\n        else if (ch == CE) {\n            if (text[i + 1] == CE) {\n                l += 1;\n                ++i;\n            }\n            i++;\n            continue;\n        }\n        l += (count ? 1 : 0);\n        ++i;\n    }\n    return [i, l];\n}\nexport function splice(text, start, len, add = '') {\n    return text.substring(0, start) + add + text.substring(start + len);\n}\nfunction advanceChars(text, start, count) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = start;\n    while (count > 0) {\n        const ch = text[i];\n        if (ch === CS) {\n            ++i;\n            while (text[i] !== CS)\n                ++i;\n            ++i;\n        }\n        else if (ch === CE) {\n            if (text[i + 1] === CE) {\n                --count;\n                ++i;\n            }\n            ++i;\n        }\n        else {\n            --count;\n            ++i;\n        }\n    }\n    return i;\n}\nexport function hyphenate(text, width, start, end, wordWidth, spaceLeftOnLine) {\n    if (wordWidth + 1 > (width * 2)) {\n        throw new Error('Cannot hyphenate - word length > 2 * width');\n    }\n    if ((spaceLeftOnLine < 4) || (spaceLeftOnLine + width < wordWidth)) {\n        text = splice(text, start - 1, 1, '\\n');\n        spaceLeftOnLine = width;\n    }\n    if (spaceLeftOnLine + width > wordWidth) {\n        // one hyphen...\n        const hyphenAt = Math.min(Math.floor(wordWidth / 2), spaceLeftOnLine - 1);\n        const w = advanceChars(text, start, hyphenAt);\n        text = splice(text, w, 0, '-\\n');\n        return [text, end + 2];\n    }\n    if (width >= wordWidth) {\n        return [text, end];\n    }\n    const hyphenAt = Math.min(wordWidth, width - 1);\n    const w = advanceChars(text, start, hyphenAt);\n    text = splice(text, w, 0, '-\\n');\n    return [text, end + 2];\n}\nexport function wordWrap(text, width, indent = 0) {\n    if (!width)\n        throw new Error('Need string and width');\n    if (text.length < width)\n        return text;\n    if (Utils.length(text) < width)\n        return text;\n    if (text.indexOf('\\n') == -1) {\n        return wrapLine(text, width, indent);\n    }\n    const lines = text.split('\\n');\n    const split = lines.map((line, i) => wrapLine(line, width, (i ? indent : 0)));\n    return split.join('\\n');\n}\n// Returns the number of lines, including the newlines already in the text.\n// Puts the output in \"to\" only if we receive a \"to\" -- can make it null and just get a line count.\nfunction wrapLine(text, width, indent = 0) {\n    if (text.length < width)\n        return text;\n    if (Utils.length(text) < width)\n        return text;\n    let spaceLeftOnLine = width;\n    width = width + indent;\n    let printString = text;\n    // Now go through and replace spaces with newlines as needed.\n    // console.log('wordWrap - ', text, width, indent);\n    let removeSpace = true;\n    let i = -1;\n    while (i < printString.length) {\n        // wordWidth counts the word width of the next word without color escapes.\n        // w indicates the position of the space or newline or null terminator that terminates the word.\n        let [w, wordWidth] = nextBreak(printString, i + (removeSpace ? 1 : 0));\n        let hyphen = false;\n        if (printString[w] == '-') {\n            w++;\n            wordWidth++;\n            hyphen = true;\n        }\n        // console.log('- w=%d, width=%d, space=%d, word=%s', w, wordWidth, spaceLeftOnLine, printString.substring(i, w));\n        if (wordWidth > width) {\n            ([printString, w] = hyphenate(printString, width, i + 1, w, wordWidth, spaceLeftOnLine));\n        }\n        else if (wordWidth == spaceLeftOnLine) {\n            const nl = (w < printString.length) ? '\\n' : '';\n            const remove = hyphen ? 0 : 1;\n            printString = splice(printString, w, remove, nl); // [i] = '\\n';\n            w += (1 - remove); // if we change the length we need to advance our pointer\n            spaceLeftOnLine = width;\n        }\n        else if (wordWidth > spaceLeftOnLine) {\n            const remove = removeSpace ? 1 : 0;\n            printString = splice(printString, i, remove, '\\n'); // [i] = '\\n';\n            w += (1 - remove); // if we change the length we need to advance our pointer\n            const extra = hyphen ? 0 : 1;\n            spaceLeftOnLine = width - wordWidth - extra; // line width minus the width of the word we just wrapped and the space\n            //printf(\"\\n\\n%s\", printString);\n        }\n        else {\n            const extra = hyphen ? 0 : 1;\n            spaceLeftOnLine -= (wordWidth + extra);\n        }\n        removeSpace = !hyphen;\n        i = w; // Advance to the terminator that follows the word.\n    }\n    return printString;\n}\n","import * as Config from './config';\nexport function eachChar(text, fn, fg, bg) {\n    const colors = [];\n    const colorFn = Config.helpers.eachColor;\n    const ctx = {\n        fg: (fg === undefined) ? Config.options.defaultFg : fg,\n        bg: (bg === undefined) ? Config.options.defaultBg : bg,\n    };\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    colorFn({ fg, bg });\n    let n = 0;\n    for (let i = 0; i < text.length; ++i) {\n        const ch = text[i];\n        if (ch == CS) {\n            let j = i + 1;\n            while (j < text.length && text[j] != CS) {\n                ++j;\n            }\n            if (j == text.length) {\n                console.warn('Reached end of string while seeking end of color start section.');\n                console.warn('- text:', text);\n                console.warn('- start @:', i);\n                return; // reached end - done (error though)\n            }\n            if (j == i + 1) { // next char\n                ++i; // fall through\n            }\n            else {\n                colors.push([ctx.fg, ctx.bg]);\n                const color = text.substring(i + 1, j);\n                ([ctx.fg, ctx.bg] = color.split('|'));\n                colorFn(ctx);\n                i = j;\n                continue;\n            }\n        }\n        else if (ch == CE) {\n            if (text[i + 1] == CE) {\n                ++i;\n            }\n            else {\n                const c = colors.pop(); // if you pop too many times colors go away\n                [ctx.fg, ctx.bg] = c || [null, null];\n                // colorFn(ctx);\n                continue;\n            }\n        }\n        fn(ch, n, ctx.fg, ctx.bg);\n        ++n;\n    }\n}\n","import { compile } from './compile';\nimport { eachChar } from './each';\nimport { length, padStart, padEnd, center, capitalize, removeColors } from './utils';\nimport { wordWrap } from './lines';\nimport { addHelper, options } from './config';\nfunction configure(opts = {}) {\n    if (opts.helpers) {\n        Object.entries(opts.helpers).forEach(([name, fn]) => {\n            addHelper(name, fn);\n        });\n    }\n    if (opts.fg) {\n        options.defaultFg = opts.fg;\n    }\n    if (opts.bg) {\n        options.defaultBg = opts.bg;\n    }\n    if (opts.colorStart) {\n        options.colorStart = opts.colorStart;\n    }\n    if (opts.colorEnd) {\n        options.colorEnd = opts.colorEnd;\n    }\n    if (opts.field) {\n        options.field = opts.field;\n    }\n}\nexport { compile, eachChar, length, padStart, padEnd, center, capitalize, removeColors, wordWrap, configure, addHelper, };\n"],"names":["options","colorStart","colorEnd","field","defaultFg","defaultBg","helpers","eachColor","addHelper","name","fn","textSegment","value","length","text","len","CS","Config.options","CE","i","ch","indexOf","nextBreak","start","l","count","splice","add","substring","advanceChars","hyphenate","width","end","wordWidth","spaceLeftOnLine","Error","Math","min","floor","wrapLine","indent","Utils.length","printString","removeSpace","w","hyphen","remove","template","F","sections","split","map","part","pattern","data","exec","helper","base","format","result","args","source","obj","undefined","fieldValue","Config.helpers","helperValue","endsWith","Number","parseInt","padEnd","padStart","stringFormat","wantSign","includes","left","intFormat","fixed","parseFloat","toFixed","floatFormat","makeVariable","f","join","fg","bg","colors","colorFn","ctx","n","j","console","warn","push","color","c","pop","pad","colorLen","rawLen","padLen","toUpperCase","out","k","line","opts","Object","entries","forEach"],"mappings":"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"}