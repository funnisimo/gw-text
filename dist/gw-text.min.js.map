{"version":3,"file":"gw-text.min.js","sources":["../js/config.js","../js/compile.js","../js/utils.js","../js/lines.js","../js/each.js","../js/index.js"],"sourcesContent":["export var options = {\n    colorStart: 'Ω',\n    colorEnd: '∆',\n    field: '§',\n    defaultFg: null,\n    defaultBg: null,\n};\n// const RE_RGB = /^[a-fA-F0-9]*$/;\n// \n// export function parseColor(color:string) {\n//   if (color.startsWith('#')) {\n//     color = color.substring(1);\n//   }\n//   else if (color.startsWith('0x')) {\n//     color = color.substring(2);\n//   }\n//   if (color.length == 3) {\n//     if (RE_RGB.test(color)) {\n//       return Number.parseInt(color, 16);\n//     }\n//   }\n//   if (color.length == 6) {\n//     if (RE_RGB.test(color)) {\n//       const v = Number.parseInt(color, 16);\n//       const r = Math.round( ((v & 0xFF0000) >> 16) / 17);\n//       const g = Math.round( ((v & 0xFF00) >> 8) / 17);\n//       const b = Math.round((v & 0xFF) / 17);\n//       return (r << 8) + (g << 4) + b;\n//     }\n//   }\n//   return 0xFFF;\n// }\nexport var helpers = {\n    eachColor: (() => { }),\n    default: ((name, _, value) => {\n        if (value !== undefined)\n            return `${value}.!!${name}!!`;\n        return `!!${name}!!`;\n    }),\n};\nexport function addHelper(name, fn) {\n    helpers[name] = fn;\n}\n","import * as Config from './config';\nexport function compile(template) {\n    const F = Config.options.field;\n    const parts = template.split(F);\n    const sections = parts.map((part, i) => {\n        if (i % 2 == 0)\n            return textSegment(part);\n        if (part.length == 0)\n            return textSegment(F);\n        return makeVariable(part);\n    });\n    return function (args = {}) {\n        return sections.map((f) => f(args)).join('');\n    };\n}\nexport function textSegment(value) {\n    return (() => value);\n}\nexport function baseValue(name) {\n    return function (args) {\n        const h = Config.helpers[name];\n        if (h)\n            return h(name, args);\n        const v = args[name];\n        if (v !== undefined)\n            return v;\n        return Config.helpers.default(name, args);\n    };\n}\nexport function fieldValue(name, source) {\n    return function (args) {\n        const obj = source(args);\n        if (!obj)\n            return Config.helpers.default(name, args, obj);\n        const value = obj[name];\n        if (value === undefined)\n            return Config.helpers.default(name, args, obj);\n        return value;\n    };\n}\nexport function helperValue(name, source) {\n    const helper = Config.helpers[name] || Config.helpers.default;\n    if (!source) {\n        return function (args) {\n            return helper(name, args, undefined);\n        };\n    }\n    return function (args) {\n        const base = source(args);\n        return helper(name, args, base);\n    };\n}\nexport function stringFormat(format, source) {\n    const data = /%(-?\\d*)s/.exec(format) || [];\n    const length = Number.parseInt(data[1] || '0');\n    return function (args) {\n        let text = '' + source(args);\n        if (length < 0) {\n            text = text.padEnd(-length);\n        }\n        else if (length) {\n            text = text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function intFormat(format, source) {\n    const data = /%([\\+-]*)(\\d*)d/.exec(format) || [];\n    let length = Number.parseInt(data[2] || '0');\n    const wantSign = data[1].includes('+');\n    const left = data[1].includes('-');\n    return function (args) {\n        const value = Number.parseInt(source(args) || 0);\n        let text = '' + value;\n        if (value > 0 && wantSign) {\n            text = '+' + text;\n        }\n        if (length && left) {\n            return text.padEnd(length);\n        }\n        else if (length) {\n            return text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function floatFormat(format, source) {\n    const data = /%([\\+-]*)(\\d*)(\\.(\\d+))?f/.exec(format) || [];\n    let length = Number.parseInt(data[2] || '0');\n    const wantSign = data[1].includes('+');\n    const left = data[1].includes('-');\n    const fixed = Number.parseInt(data[4]) || 0;\n    return function (args) {\n        const value = Number.parseFloat(source(args) || 0);\n        let text;\n        if (fixed) {\n            text = value.toFixed(fixed);\n        }\n        else {\n            text = '' + value;\n        }\n        if (value > 0 && wantSign) {\n            text = '+' + text;\n        }\n        if (length && left) {\n            return text.padEnd(length);\n        }\n        else if (length) {\n            return text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function makeVariable(pattern) {\n    const data = /((\\w+) )?(\\w+)(\\.(\\w+))?(%[\\+\\.\\-\\d]*[dsf])?/.exec(pattern) || [];\n    const helper = data[2];\n    const base = data[3];\n    const field = data[5];\n    const format = data[6];\n    let result = baseValue(base);\n    if (field && field.length) {\n        result = fieldValue(field, result);\n    }\n    if (helper && helper.length) {\n        result = helperValue(helper, result);\n    }\n    if (format && format.length) {\n        if (format.endsWith('s')) {\n            result = stringFormat(format, result);\n        }\n        else if (format.endsWith('d')) {\n            result = intFormat(format, result);\n        }\n        else if (format.endsWith('f')) {\n            result = floatFormat(format, result);\n        }\n    }\n    return result;\n}\n","import * as Config from './config';\nexport function length(text) {\n    if (!text || text.length == 0)\n        return 0;\n    let len = 0;\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    for (let i = 0; i < text.length; ++i) {\n        const ch = text[i];\n        if (ch == CS) {\n            const end = text.indexOf(CS, i + 1);\n            i = end;\n        }\n        else if (ch == CE) {\n            // skip\n        }\n        else {\n            ++len;\n        }\n    }\n    return len;\n}\nexport function advanceChars(text, start, count) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = start;\n    while (count > 0) {\n        const ch = text[i];\n        if (ch === CS) {\n            ++i;\n            while (text[i] !== CS)\n                ++i;\n            ++i;\n        }\n        else if (ch === CE) {\n            if (text[i + 1] === CE) {\n                --count;\n                ++i;\n            }\n            ++i;\n        }\n        else {\n            --count;\n            ++i;\n        }\n    }\n    return i;\n}\nexport function firstChar(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = 0;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch === CS) {\n            if (text[i + 1] === CS)\n                return CS;\n            ++i;\n            while (text[i] !== CS)\n                ++i;\n            ++i;\n        }\n        else if (ch === CE) {\n            if (text[i + 1] === CE)\n                return CE;\n            ++i;\n        }\n        else {\n            return ch;\n        }\n    }\n    return null;\n}\nexport function padStart(text, width, pad = ' ') {\n    const colorLen = text.length - length(text);\n    return text.padStart(width + colorLen, pad);\n}\nexport function padEnd(text, width, pad = ' ') {\n    const colorLen = text.length - length(text);\n    return text.padEnd(width + colorLen, pad);\n}\nexport function center(text, width, pad = ' ') {\n    const rawLen = text.length;\n    const len = length(text);\n    const padLen = width - len;\n    if (padLen <= 0)\n        return text;\n    const left = Math.floor(padLen / 2);\n    return text.padStart(rawLen + left, pad).padEnd(rawLen + padLen, pad);\n}\nexport function capitalize(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = 0;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch == CS) {\n            ++i;\n            while (text[i] != CS && i < text.length) {\n                ++i;\n            }\n            ++i;\n        }\n        else if (ch == CE) {\n            ++i;\n            while (text[i] == CS && i < text.length) {\n                ++i;\n            }\n        }\n        else {\n            return text.substring(0, i) + ch.toUpperCase() + text.substring(i + 1);\n        }\n    }\n    return text;\n}\nexport function removeColors(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let out = '';\n    let start = 0;\n    for (let i = 0; i < text.length; ++i) {\n        const k = text[i];\n        if (k === CS) {\n            if (text[i + 1] == CS) {\n                ++i;\n                continue;\n            }\n            out += text.substring(start, i);\n            ++i;\n            while (text[i] != CS && i < text.length) {\n                ++i;\n            }\n            start = i + 1;\n        }\n        else if (k === CE) {\n            if (text[i + 1] == CE) {\n                ++i;\n                continue;\n            }\n            out += text.substring(start, i);\n            start = i + 1;\n        }\n    }\n    if (start == 0)\n        return text;\n    out += text.substring(start);\n    return out;\n}\n","import * as Config from './config';\nimport * as Utils from './utils';\nexport function nextBreak(text, start) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = start;\n    let l = 0;\n    let count = true;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch == ' ') {\n            while (text[i + 1] == ' ')\n                ++i;\n            return [i, l];\n        }\n        if (ch == '-') {\n            return [i, l];\n        }\n        if (ch == '\\n') {\n            return [i, l];\n        }\n        if (ch == CS) {\n            if (text[i + 1] == CS && count) {\n                l += 1;\n                i += 2;\n                continue;\n            }\n            count = !count;\n            ++i;\n            continue;\n        }\n        else if (ch == CE) {\n            if (text[i + 1] == CE) {\n                l += 1;\n                ++i;\n            }\n            i++;\n            continue;\n        }\n        l += (count ? 1 : 0);\n        ++i;\n    }\n    return [i, l];\n}\nexport function splice(text, start, len, add = '') {\n    return text.substring(0, start) + add + text.substring(start + len);\n}\nexport function hyphenate(text, width, start, end, wordWidth, spaceLeftOnLine) {\n    if (wordWidth + 1 > (width * 2)) {\n        throw new Error('Cannot hyphenate - word length > 2 * width');\n    }\n    if ((spaceLeftOnLine < 4) || (spaceLeftOnLine + width < wordWidth)) {\n        text = splice(text, start - 1, 1, '\\n');\n        spaceLeftOnLine = width;\n    }\n    if (spaceLeftOnLine + width > wordWidth) {\n        // one hyphen...\n        const hyphenAt = Math.min(Math.floor(wordWidth / 2), spaceLeftOnLine - 1);\n        const w = Utils.advanceChars(text, start, hyphenAt);\n        text = splice(text, w, 0, '-\\n');\n        return [text, end + 2];\n    }\n    if (width >= wordWidth) {\n        return [text, end];\n    }\n    const hyphenAt = Math.min(wordWidth, width - 1);\n    const w = Utils.advanceChars(text, start, hyphenAt);\n    text = splice(text, w, 0, '-\\n');\n    return [text, end + 2];\n}\nexport function wordWrap(text, width, indent = 0) {\n    if (!width)\n        throw new Error('Need string and width');\n    if (text.length < width)\n        return text;\n    if (Utils.length(text) < width)\n        return text;\n    if (text.indexOf('\\n') == -1) {\n        return wrapLine(text, width, indent);\n    }\n    const lines = text.split('\\n');\n    const split = lines.map((line, i) => wrapLine(line, width, (i ? indent : 0)));\n    return split.join('\\n');\n}\n// Returns the number of lines, including the newlines already in the text.\n// Puts the output in \"to\" only if we receive a \"to\" -- can make it null and just get a line count.\nfunction wrapLine(text, width, indent = 0) {\n    if (text.length < width)\n        return text;\n    if (Utils.length(text) < width)\n        return text;\n    let spaceLeftOnLine = width;\n    width = width - indent;\n    let printString = text;\n    // Now go through and replace spaces with newlines as needed.\n    // console.log('wordWrap - ', text, width, indent);\n    let removeSpace = true;\n    let i = -1;\n    while (i < printString.length) {\n        // wordWidth counts the word width of the next word without color escapes.\n        // w indicates the position of the space or newline or null terminator that terminates the word.\n        let [w, wordWidth] = nextBreak(printString, i + (removeSpace ? 1 : 0));\n        let hyphen = false;\n        if (printString[w] == '-') {\n            w++;\n            wordWidth++;\n            hyphen = true;\n        }\n        // console.log('- w=%d, width=%d, space=%d, word=%s', w, wordWidth, spaceLeftOnLine, printString.substring(i, w));\n        if (wordWidth > width) {\n            ([printString, w] = hyphenate(printString, width, i + 1, w, wordWidth, spaceLeftOnLine));\n        }\n        else if (wordWidth == spaceLeftOnLine) {\n            const nl = (w < printString.length) ? '\\n' : '';\n            const remove = hyphen ? 0 : 1;\n            printString = splice(printString, w, remove, nl); // [i] = '\\n';\n            w += (1 - remove); // if we change the length we need to advance our pointer\n            spaceLeftOnLine = width;\n        }\n        else if (wordWidth > spaceLeftOnLine) {\n            const remove = removeSpace ? 1 : 0;\n            printString = splice(printString, i, remove, '\\n'); // [i] = '\\n';\n            w += (1 - remove); // if we change the length we need to advance our pointer\n            const extra = hyphen ? 0 : 1;\n            spaceLeftOnLine = width - wordWidth - extra; // line width minus the width of the word we just wrapped and the space\n            //printf(\"\\n\\n%s\", printString);\n        }\n        else {\n            const extra = hyphen ? 0 : 1;\n            spaceLeftOnLine -= (wordWidth + extra);\n        }\n        removeSpace = !hyphen;\n        i = w; // Advance to the terminator that follows the word.\n    }\n    return printString;\n}\n","import * as Config from './config';\nexport function eachChar(text, fn, fg, bg) {\n    if (!text || text.length == 0)\n        return;\n    const colors = [];\n    const colorFn = Config.helpers.eachColor;\n    const ctx = {\n        fg: (fg === undefined) ? Config.options.defaultFg : fg,\n        bg: (bg === undefined) ? Config.options.defaultBg : bg,\n    };\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    colorFn({ fg, bg });\n    let n = 0;\n    for (let i = 0; i < text.length; ++i) {\n        const ch = text[i];\n        if (ch == CS) {\n            let j = i + 1;\n            while (j < text.length && text[j] != CS) {\n                ++j;\n            }\n            if (j == text.length) {\n                console.warn('Reached end of string while seeking end of color start section.');\n                console.warn('- text:', text);\n                console.warn('- start @:', i);\n                return; // reached end - done (error though)\n            }\n            if (j == i + 1) { // next char\n                ++i; // fall through\n            }\n            else {\n                colors.push([ctx.fg, ctx.bg]);\n                const color = text.substring(i + 1, j);\n                ([ctx.fg, ctx.bg] = color.split('|'));\n                colorFn(ctx);\n                i = j;\n                continue;\n            }\n        }\n        else if (ch == CE) {\n            if (text[i + 1] == CE) {\n                ++i;\n            }\n            else {\n                const c = colors.pop(); // if you pop too many times colors go away\n                [ctx.fg, ctx.bg] = c || [null, null];\n                // colorFn(ctx);\n                continue;\n            }\n        }\n        fn(ch, ctx.fg, ctx.bg, n, i);\n        ++n;\n    }\n}\n","import { compile } from './compile';\nimport { eachChar } from './each';\nimport { length, padStart, padEnd, center, capitalize, removeColors, firstChar } from './utils';\nimport { wordWrap } from './lines';\nimport { addHelper, options } from './config';\nfunction configure(opts = {}) {\n    if (opts.helpers) {\n        Object.entries(opts.helpers).forEach(([name, fn]) => {\n            addHelper(name, fn);\n        });\n    }\n    if (opts.fg) {\n        options.defaultFg = opts.fg;\n    }\n    if (opts.bg) {\n        options.defaultBg = opts.bg;\n    }\n    if (opts.colorStart) {\n        options.colorStart = opts.colorStart;\n    }\n    if (opts.colorEnd) {\n        options.colorEnd = opts.colorEnd;\n    }\n    if (opts.field) {\n        options.field = opts.field;\n    }\n}\nexport { compile, eachChar, length, padStart, padEnd, center, firstChar, capitalize, removeColors, wordWrap, configure, addHelper, options };\n"],"names":["options","colorStart","colorEnd","field","defaultFg","defaultBg","helpers","eachColor","default","name","_","value","undefined","addHelper","fn","textSegment","length","text","len","CS","Config.options","CE","i","ch","indexOf","advanceChars","start","count","nextBreak","l","splice","add","substring","hyphenate","width","end","wordWidth","spaceLeftOnLine","Error","Utils.advanceChars","Math","min","floor","wrapLine","indent","Utils.length","printString","removeSpace","w","hyphen","remove","template","F","sections","split","map","part","pattern","data","exec","helper","base","format","result","args","h","Config.helpers","v","source","obj","fieldValue","helperValue","endsWith","Number","parseInt","padEnd","padStart","stringFormat","wantSign","includes","left","intFormat","fixed","parseFloat","toFixed","floatFormat","makeVariable","f","join","fg","bg","colors","colorFn","ctx","n","j","console","warn","push","color","c","pop","pad","colorLen","rawLen","padLen","toUpperCase","out","k","line","opts","Object","entries","forEach"],"mappings":"gPAAO,IAAIA,EAAU,CACjBC,WAAY,IACZC,SAAU,IACVC,MAAO,IACPC,UAAW,KACXC,UAAW,MA2BJC,EAAU,CACjBC,iBACAC,SAAWC,EAAMC,EAAGC,SACFC,IAAVD,EACO,GAAGA,OAAWF,MAClB,KAAKA,OAGb,SAASI,EAAUJ,EAAMK,GAC5BR,EAAQG,GAAQK,EC1Bb,SAASC,EAAYJ,GACxB,UAAcA,ECfX,SAASK,EAAOC,GACnB,IAAKA,GAAuB,GAAfA,EAAKD,OACd,OAAO,EACX,IAAIE,EAAM,EACV,MAAMC,EAAKC,EAAenB,WACpBoB,EAAKD,EAAelB,SAC1B,IAAK,IAAIoB,EAAI,EAAGA,EAAIL,EAAKD,SAAUM,EAAG,CAClC,MAAMC,EAAKN,EAAKK,GAChB,GAAIC,GAAMJ,EAAI,CAEVG,EADYL,EAAKO,QAAQL,EAAIG,EAAI,QAG5BC,GAAMF,KAITH,EAGV,OAAOA,EAEJ,SAASO,EAAaR,EAAMS,EAAOC,GACtC,MAAMR,EAAKC,EAAenB,WACpBoB,EAAKD,EAAelB,SAC1B,IAAIoB,EAAII,EACR,KAAOC,EAAQ,GAAG,CACd,MAAMJ,EAAKN,EAAKK,GAChB,GAAIC,IAAOJ,EAAI,CAEX,MADEG,EACKL,EAAKK,KAAOH,KACbG,IACJA,OAEGC,IAAOF,GACRJ,EAAKK,EAAI,KAAOD,MACdM,IACAL,KAEJA,MAGAK,IACAL,GAGV,OAAOA,EC5CJ,SAASM,EAAUX,EAAMS,GAC5B,MAAMP,EAAKC,EAAenB,WACpBoB,EAAKD,EAAelB,SAC1B,IAAIoB,EAAII,EACJG,EAAI,EACJF,GAAQ,EACZ,KAAOL,EAAIL,EAAKD,QAAQ,CACpB,MAAMO,EAAKN,EAAKK,GAChB,GAAU,KAANC,EAAW,CACX,KAAsB,KAAfN,EAAKK,EAAI,MACVA,EACN,MAAO,CAACA,EAAGO,GAEf,GAAU,KAANN,EACA,MAAO,CAACD,EAAGO,GAEf,GAAU,MAANN,EACA,MAAO,CAACD,EAAGO,GAEf,GAAIN,GAAMJ,EAUDI,GAAMF,GAQfQ,GAAMF,EAAQ,EAAI,IAChBL,IARML,EAAKK,EAAI,IAAMD,IACfQ,GAAK,IACHP,GAENA,SAfJ,CACI,GAAIL,EAAKK,EAAI,IAAMH,GAAMQ,EAAO,CAC5BE,GAAK,EACLP,GAAK,EACL,SAEJK,GAASA,IACPL,GAcV,MAAO,CAACA,EAAGO,GAER,SAASC,EAAOb,EAAMS,EAAOR,EAAKa,EAAM,IAC3C,OAAOd,EAAKe,UAAU,EAAGN,GAASK,EAAMd,EAAKe,UAAUN,EAAQR,GAE5D,SAASe,EAAUhB,EAAMiB,EAAOR,EAAOS,EAAKC,EAAWC,GAC1D,GAAID,EAAY,EAAa,EAARF,EACjB,MAAM,IAAII,MAAM,8CAMpB,IAJKD,EAAkB,GAAOA,EAAkBH,EAAQE,KACpDnB,EAAOa,EAAOb,EAAMS,EAAQ,EAAG,EAAG,MAClCW,EAAkBH,GAElBG,EAAkBH,EAAQE,EAAW,CAKrC,MAAO,CADPnB,EAAOa,EAAOb,EADJsB,EAAmBtB,EAAMS,EADlBc,KAAKC,IAAID,KAAKE,MAAMN,EAAY,GAAIC,EAAkB,IAEhD,EAAG,OACZF,EAAM,GAExB,GAAID,GAASE,EACT,MAAO,CAACnB,EAAMkB,GAKlB,MAAO,CADPlB,EAAOa,EAAOb,EADJsB,EAAmBtB,EAAMS,EADlBc,KAAKC,IAAIL,EAAWF,EAAQ,IAEtB,EAAG,OACZC,EAAM,GAkBxB,SAASQ,EAAS1B,EAAMiB,EAAOU,EAAS,GACpC,GAAI3B,EAAKD,OAASkB,EACd,OAAOjB,EACX,GAAI4B,EAAa5B,GAAQiB,EACrB,OAAOjB,EACX,IAAIoB,EAAkBH,EACtBA,GAAgBU,EAChB,IAAIE,EAAc7B,EAGd8B,GAAc,EACdzB,GAAK,EACT,KAAOA,EAAIwB,EAAY9B,QAAQ,CAG3B,IAAKgC,EAAGZ,GAAaR,EAAUkB,EAAaxB,GAAKyB,EAAc,EAAI,IAC/DE,GAAS,EAOb,GANsB,KAAlBH,EAAYE,KACZA,IACAZ,IACAa,GAAS,GAGTb,EAAYF,GACVY,EAAaE,GAAKf,EAAUa,EAAaZ,EAAOZ,EAAI,EAAG0B,EAAGZ,EAAWC,QAEtE,GAAID,GAAaC,EAAiB,CACnC,MACMa,EAASD,EAAS,EAAI,EAC5BH,EAAchB,EAAOgB,EAAaE,EAAGE,EAFzBF,EAAIF,EAAY9B,OAAU,KAAO,IAG7CgC,GAAM,EAAIE,EACVb,EAAkBH,OAEjB,GAAIE,EAAYC,EAAiB,CAClC,MAAMa,EAASH,EAAc,EAAI,EACjCD,EAAchB,EAAOgB,EAAaxB,EAAG4B,EAAQ,MAC7CF,GAAM,EAAIE,EAEVb,EAAkBH,EAAQE,GADZa,EAAS,EAAI,OAI1B,CAEDZ,GAAoBD,GADNa,EAAS,EAAI,GAG/BF,GAAeE,EACf3B,EAAI0B,EAER,OAAOF,gCFrIJ,SAAiBK,GACpB,MAAMC,EAAIhC,EAAejB,MAEnBkD,EADQF,EAASG,MAAMF,GACNG,KAAI,CAACC,EAAMlC,IAC1BA,EAAI,GAAK,EACFP,EAAYyC,GACJ,GAAfA,EAAKxC,OACED,EAAYqC,GAyGxB,SAAsBK,GACzB,MAAMC,EAAO,+CAA+CC,KAAKF,IAAY,GACvEG,EAASF,EAAK,GACdG,EAAOH,EAAK,GACZvD,EAAQuD,EAAK,GACbI,EAASJ,EAAK,GACpB,IAAIK,GArGkBtD,EAqGCoD,EApGhB,SAAUG,GACb,MAAMC,EAAIC,EAAezD,GACzB,GAAIwD,EACA,OAAOA,EAAExD,EAAMuD,GACnB,MAAMG,EAAIH,EAAKvD,GACf,YAAUG,IAANuD,EACOA,EACJD,EAAe1D,QAAQC,EAAMuD,KARrC,IAAmBvD,EAsGlBN,GAASA,EAAMa,SACf+C,EA5FD,SAAoBtD,EAAM2D,GAC7B,OAAO,SAAUJ,GACb,MAAMK,EAAMD,EAAOJ,GACnB,IAAKK,EACD,OAAOH,EAAe1D,QAAQC,EAAMuD,EAAMK,GAC9C,MAAM1D,EAAQ0D,EAAI5D,GAClB,YAAcG,IAAVD,EACOuD,EAAe1D,QAAQC,EAAMuD,EAAMK,GACvC1D,GAoFE2D,CAAWnE,EAAO4D,IAE3BH,GAAUA,EAAO5C,SACjB+C,EApFD,SAAqBtD,EAAM2D,GAC9B,MAAMR,EAASM,EAAezD,IAASyD,EAAe1D,QACtD,IAAK4D,EACD,OAAO,SAAUJ,GACb,OAAOJ,EAAOnD,EAAMuD,OAAMpD,IAGlC,OAAO,SAAUoD,GACb,MAAMH,EAAOO,EAAOJ,GACpB,OAAOJ,EAAOnD,EAAMuD,EAAMH,IA2EjBU,CAAYX,EAAQG,IAE7BD,GAAUA,EAAO9C,SACb8C,EAAOU,SAAS,KAChBT,EA5EL,SAAsBD,EAAQM,GACjC,MAAMV,EAAO,YAAYC,KAAKG,IAAW,GACnC9C,EAASyD,OAAOC,SAAShB,EAAK,IAAM,KAC1C,OAAO,SAAUM,GACb,IAAI/C,EAAO,GAAKmD,EAAOJ,GAOvB,OANIhD,EAAS,EACTC,EAAOA,EAAK0D,QAAQ3D,GAEfA,IACLC,EAAOA,EAAK2D,SAAS5D,IAElBC,GAiEM4D,CAAaf,EAAQC,GAEzBD,EAAOU,SAAS,KACrBT,EAjEL,SAAmBD,EAAQM,GAC9B,MAAMV,EAAO,kBAAkBC,KAAKG,IAAW,GAC/C,IAAI9C,EAASyD,OAAOC,SAAShB,EAAK,IAAM,KACxC,MAAMoB,EAAWpB,EAAK,GAAGqB,SAAS,KAC5BC,EAAOtB,EAAK,GAAGqB,SAAS,KAC9B,OAAO,SAAUf,GACb,MAAMrD,EAAQ8D,OAAOC,SAASN,EAAOJ,IAAS,GAC9C,IAAI/C,EAAO,GAAKN,EAIhB,OAHIA,EAAQ,GAAKmE,IACb7D,EAAO,IAAMA,GAEbD,GAAUgE,EACH/D,EAAK0D,OAAO3D,GAEdA,EACEC,EAAK2D,SAAS5D,GAElBC,GAgDMgE,CAAUnB,EAAQC,GAEtBD,EAAOU,SAAS,OACrBT,EAhDL,SAAqBD,EAAQM,GAChC,MAAMV,EAAO,4BAA4BC,KAAKG,IAAW,GACzD,IAAI9C,EAASyD,OAAOC,SAAShB,EAAK,IAAM,KACxC,MAAMoB,EAAWpB,EAAK,GAAGqB,SAAS,KAC5BC,EAAOtB,EAAK,GAAGqB,SAAS,KACxBG,EAAQT,OAAOC,SAAShB,EAAK,KAAO,EAC1C,OAAO,SAAUM,GACb,MAAMrD,EAAQ8D,OAAOU,WAAWf,EAAOJ,IAAS,GAChD,IAAI/C,EAUJ,OARIA,EADAiE,EACOvE,EAAMyE,QAAQF,GAGd,GAAKvE,EAEZA,EAAQ,GAAKmE,IACb7D,EAAO,IAAMA,GAEbD,GAAUgE,EACH/D,EAAK0D,OAAO3D,GAEdA,EACEC,EAAK2D,SAAS5D,GAElBC,GAwBMoE,CAAYvB,EAAQC,KAGrC,OAAOA,EAhIIuB,CAAa9B,KAExB,OAAO,SAAUQ,EAAO,IACpB,OAAOX,EAASE,KAAKgC,GAAMA,EAAEvB,KAAOwB,KAAK,eGX1C,SAAkBvE,EAAMH,EAAI2E,EAAIC,GACnC,IAAKzE,GAAuB,GAAfA,EAAKD,OACd,OACJ,MAAM2E,EAAS,GACTC,EAAU1B,EAAe3D,UACzBsF,EAAM,CACRJ,QAAY7E,IAAP6E,EAAoBrE,EAAehB,UAAYqF,EACpDC,QAAY9E,IAAP8E,EAAoBtE,EAAef,UAAYqF,GAElDvE,EAAKC,EAAenB,WACpBoB,EAAKD,EAAelB,SAC1B0F,EAAQ,CAAEH,GAAAA,EAAIC,GAAAA,IACd,IAAII,EAAI,EACR,IAAK,IAAIxE,EAAI,EAAGA,EAAIL,EAAKD,SAAUM,EAAG,CAClC,MAAMC,EAAKN,EAAKK,GAChB,GAAIC,GAAMJ,EAAI,CACV,IAAI4E,EAAIzE,EAAI,EACZ,KAAOyE,EAAI9E,EAAKD,QAAUC,EAAK8E,IAAM5E,KAC/B4E,EAEN,GAAIA,GAAK9E,EAAKD,OAIV,OAHAgF,QAAQC,KAAK,mEACbD,QAAQC,KAAK,UAAWhF,QACxB+E,QAAQC,KAAK,aAAc3E,GAG/B,GAAIyE,GAAKzE,EAAI,EAGR,CACDqE,EAAOO,KAAK,CAACL,EAAIJ,GAAII,EAAIH,KACzB,MAAMS,EAAQlF,EAAKe,UAAUV,EAAI,EAAGyE,IAClCF,EAAIJ,GAAII,EAAIH,IAAMS,EAAM7C,MAAM,KAChCsC,EAAQC,GACRvE,EAAIyE,EACJ,WAREzE,OAWL,GAAIC,GAAMF,EAAI,CACf,GAAIJ,EAAKK,EAAI,IAAMD,EAGd,CACD,MAAM+E,EAAIT,EAAOU,OAChBR,EAAIJ,GAAII,EAAIH,IAAMU,GAAK,CAAC,KAAM,MAE/B,WANE9E,EASVR,EAAGS,EAAIsE,EAAIJ,GAAII,EAAIH,GAAII,EAAGxE,KACxBwE,sBFsBH,SAAkB7E,EAAMiB,EAAOoE,EAAM,KACxC,MAAMC,EAAWtF,EAAKD,OAASA,EAAOC,GACtC,OAAOA,EAAK2D,SAAS1C,EAAQqE,EAAUD,WAEpC,SAAgBrF,EAAMiB,EAAOoE,EAAM,KACtC,MAAMC,EAAWtF,EAAKD,OAASA,EAAOC,GACtC,OAAOA,EAAK0D,OAAOzC,EAAQqE,EAAUD,WAElC,SAAgBrF,EAAMiB,EAAOoE,EAAM,KACtC,MAAME,EAASvF,EAAKD,OAEdyF,EAASvE,EADHlB,EAAOC,GAEnB,GAAIwF,GAAU,EACV,OAAOxF,EACX,MAAM+D,EAAOxC,KAAKE,MAAM+D,EAAS,GACjC,OAAOxF,EAAK2D,SAAS4B,EAASxB,EAAMsB,GAAK3B,OAAO6B,EAASC,EAAQH,cAxC9D,SAAmBrF,GACtB,MAAME,EAAKC,EAAenB,WACpBoB,EAAKD,EAAelB,SAC1B,IAAIoB,EAAI,EACR,KAAOA,EAAIL,EAAKD,QAAQ,CACpB,MAAMO,EAAKN,EAAKK,GAChB,GAAIC,IAAOJ,EAAI,CACX,GAAIF,EAAKK,EAAI,KAAOH,EAChB,OAAOA,EAEX,MADEG,EACKL,EAAKK,KAAOH,KACbG,IACJA,MAED,CAAA,GAAIC,IAAOF,EAMZ,OAAOE,EALP,GAAIN,EAAKK,EAAI,KAAOD,EAChB,OAAOA,IACTC,GAMV,OAAO,iBAmBJ,SAAoBL,GACvB,MAAME,EAAKC,EAAenB,WACpBoB,EAAKD,EAAelB,SAC1B,IAAIoB,EAAI,EACR,KAAOA,EAAIL,EAAKD,QAAQ,CACpB,MAAMO,EAAKN,EAAKK,GAChB,GAAIC,GAAMJ,EAAI,CAEV,MADEG,EACKL,EAAKK,IAAMH,GAAMG,EAAIL,EAAKD,UAC3BM,IAEJA,MAED,CAAA,GAAIC,GAAMF,EAOX,OAAOJ,EAAKe,UAAU,EAAGV,GAAKC,EAAGmF,cAAgBzF,EAAKe,UAAUV,EAAI,GALpE,MADEA,EACKL,EAAKK,IAAMH,GAAMG,EAAIL,EAAKD,UAC3BM,GAOd,OAAOL,gBAEJ,SAAsBA,GACzB,MAAME,EAAKC,EAAenB,WACpBoB,EAAKD,EAAelB,SAC1B,IAAIyG,EAAM,GACNjF,EAAQ,EACZ,IAAK,IAAIJ,EAAI,EAAGA,EAAIL,EAAKD,SAAUM,EAAG,CAClC,MAAMsF,EAAI3F,EAAKK,GACf,GAAIsF,IAAMzF,EAAI,CACV,GAAIF,EAAKK,EAAI,IAAMH,EAAI,GACjBG,EACF,SAIJ,IAFAqF,GAAO1F,EAAKe,UAAUN,EAAOJ,KAC3BA,EACKL,EAAKK,IAAMH,GAAMG,EAAIL,EAAKD,UAC3BM,EAENI,EAAQJ,EAAI,OAEX,GAAIsF,IAAMvF,EAAI,CACf,GAAIJ,EAAKK,EAAI,IAAMD,EAAI,GACjBC,EACF,SAEJqF,GAAO1F,EAAKe,UAAUN,EAAOJ,GAC7BI,EAAQJ,EAAI,GAGpB,OAAa,GAATI,EACOT,GACX0F,GAAO1F,EAAKe,UAAUN,GACfiF,aC5EJ,SAAkB1F,EAAMiB,EAAOU,EAAS,GAC3C,IAAKV,EACD,MAAM,IAAII,MAAM,yBACpB,OAAIrB,EAAKD,OAASkB,GAEdW,EAAa5B,GAAQiB,EADdjB,GAGgB,GAAvBA,EAAKO,QAAQ,MACNmB,EAAS1B,EAAMiB,EAAOU,GAEnB3B,EAAKqC,MAAM,MACLC,KAAI,CAACsD,EAAMvF,IAAMqB,EAASkE,EAAM3E,EAAQZ,EAAIsB,EAAS,KAC5D4C,KAAK,iBE7EtB,SAAmBsB,EAAO,IAClBA,EAAKxG,SACLyG,OAAOC,QAAQF,EAAKxG,SAAS2G,SAAQ,EAAExG,EAAMK,MACzCD,EAAUJ,EAAMK,MAGpBgG,EAAKrB,KACLzF,EAAQI,UAAY0G,EAAKrB,IAEzBqB,EAAKpB,KACL1F,EAAQK,UAAYyG,EAAKpB,IAEzBoB,EAAK7G,aACLD,EAAQC,WAAa6G,EAAK7G,YAE1B6G,EAAK5G,WACLF,EAAQE,SAAW4G,EAAK5G,UAExB4G,EAAK3G,QACLH,EAAQG,MAAQ2G,EAAK3G"}