{"version":3,"file":"gw-text.min.js","sources":["../js/config.js","../js/compile.js","../js/utils.js","../js/lines.js","../js/each.js","../js/index.js"],"sourcesContent":["export var options = {\n    colorStart: 'Ω',\n    colorEnd: '∆',\n    field: '§',\n    defaultFg: null,\n    defaultBg: null,\n};\n// const RE_RGB = /^[a-fA-F0-9]*$/;\n// \n// export function parseColor(color:string) {\n//   if (color.startsWith('#')) {\n//     color = color.substring(1);\n//   }\n//   else if (color.startsWith('0x')) {\n//     color = color.substring(2);\n//   }\n//   if (color.length == 3) {\n//     if (RE_RGB.test(color)) {\n//       return Number.parseInt(color, 16);\n//     }\n//   }\n//   if (color.length == 6) {\n//     if (RE_RGB.test(color)) {\n//       const v = Number.parseInt(color, 16);\n//       const r = Math.round( ((v & 0xFF0000) >> 16) / 17);\n//       const g = Math.round( ((v & 0xFF00) >> 8) / 17);\n//       const b = Math.round((v & 0xFF) / 17);\n//       return (r << 8) + (g << 4) + b;\n//     }\n//   }\n//   return 0xFFF;\n// }\nexport var helpers = {\n    eachColor: (() => { }),\n};\nexport function addHelper(name, fn) {\n    helpers[name] = fn;\n}\n","import * as Config from './config';\nexport function compile(template) {\n    const F = Config.options.field;\n    console.log('Field = ', F);\n    const parts = template.split(F);\n    const sections = parts.map((part, i) => {\n        if (i % 2 == 0)\n            return textSegment(part);\n        if (part.length == 0)\n            return textSegment(F);\n        return makeVariable(part);\n    });\n    return function (args) {\n        return sections.map((f) => f(args)).join('');\n    };\n}\nexport function textSegment(value) {\n    return (() => value);\n}\nexport function baseValue(name) {\n    return function (args) { return args[name] || `!!${name}!!`; };\n}\nexport function fieldValue(name, source) {\n    return function (args) {\n        const obj = source(args);\n        if (!obj)\n            return `!!null.${name}!!`;\n        const value = obj[name];\n        if (value === undefined)\n            return `!!${'' + obj}.${name}!!`;\n        return value;\n    };\n}\nexport function helperValue(name, source) {\n    const helper = Config.helpers[name];\n    if (!helper) {\n        return (() => `Missing Helper:${name}`);\n    }\n    if (!source) {\n        return function (args) {\n            return helper(name, args, undefined);\n        };\n    }\n    return function (args) {\n        const base = source(args);\n        return helper(name, args, base);\n    };\n}\nexport function stringFormat(format, source) {\n    const data = /%(-?\\d*)s/.exec(format) || [];\n    const length = Number.parseInt(data[1] || '0');\n    return function (args) {\n        let text = '' + source(args);\n        if (length < 0) {\n            text = text.padEnd(-length);\n        }\n        else if (length) {\n            text = text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function intFormat(format, source) {\n    const data = /%([\\+-]*)(\\d*)d/.exec(format) || [];\n    let length = Number.parseInt(data[2] || '0');\n    const wantSign = data[1].includes('+');\n    const left = data[1].includes('-');\n    return function (args) {\n        const value = Number.parseInt(source(args) || 0);\n        let text = '' + value;\n        if (value > 0 && wantSign) {\n            text = '+' + text;\n        }\n        if (length && left) {\n            return text.padEnd(length);\n        }\n        else if (length) {\n            return text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function floatFormat(format, source) {\n    const data = /%([\\+-]*)(\\d*)(\\.(\\d+))?f/.exec(format) || [];\n    let length = Number.parseInt(data[2] || '0');\n    const wantSign = data[1].includes('+');\n    const left = data[1].includes('-');\n    const fixed = Number.parseInt(data[4]) || 0;\n    return function (args) {\n        const value = Number.parseFloat(source(args) || 0);\n        let text;\n        if (fixed) {\n            text = value.toFixed(fixed);\n        }\n        else {\n            text = '' + value;\n        }\n        if (value > 0 && wantSign) {\n            text = '+' + text;\n        }\n        if (length && left) {\n            return text.padEnd(length);\n        }\n        else if (length) {\n            return text.padStart(length);\n        }\n        return text;\n    };\n}\nexport function makeVariable(pattern) {\n    const data = /((\\w+) )?(\\w+)(\\.(\\w+))?(%[\\+\\.\\-\\d]*[dsf])?/.exec(pattern) || [];\n    const helper = data[2];\n    const base = data[3];\n    const field = data[5];\n    const format = data[6];\n    let result = baseValue(base);\n    if (field && field.length) {\n        result = fieldValue(field, result);\n    }\n    if (helper && helper.length) {\n        result = helperValue(helper, result);\n    }\n    if (format && format.length) {\n        if (format.endsWith('s')) {\n            result = stringFormat(format, result);\n        }\n        else if (format.endsWith('d')) {\n            result = intFormat(format, result);\n        }\n        else if (format.endsWith('f')) {\n            result = floatFormat(format, result);\n        }\n    }\n    return result;\n}\n","import * as Config from './config';\nexport function length(text) {\n    let len = 0;\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    for (let i = 0; i < text.length; ++i) {\n        const ch = text[i];\n        if (ch == CS) {\n            const end = text.indexOf(CS, i + 1);\n            i = end;\n        }\n        else if (ch == CE) {\n            // skip\n        }\n        else {\n            ++len;\n        }\n    }\n    return len;\n}\nexport function padStart(text, width, pad = ' ') {\n    const colorLen = text.length - length(text);\n    return text.padStart(width + colorLen, pad);\n}\nexport function padEnd(text, width, pad = ' ') {\n    const colorLen = text.length - length(text);\n    return text.padEnd(width + colorLen, pad);\n}\nexport function center(text, width, pad = ' ') {\n    const rawLen = text.length;\n    const len = length(text);\n    const padLen = width - len;\n    if (padLen <= 0)\n        return text;\n    const left = Math.floor(padLen / 2);\n    return text.padStart(rawLen + left, pad).padEnd(rawLen + padLen, pad);\n}\nexport function capitalize(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = 0;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch == CS) {\n            ++i;\n            while (text[i] != CS && i < text.length) {\n                ++i;\n            }\n            ++i;\n        }\n        else if (ch == CE) {\n            ++i;\n            while (text[i] == CS && i < text.length) {\n                ++i;\n            }\n        }\n        else {\n            return text.substring(0, i) + ch.toUpperCase() + text.substring(i + 1);\n        }\n    }\n    return text;\n}\nexport function removeColors(text) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let out = '';\n    let start = 0;\n    for (let i = 0; i < text.length; ++i) {\n        const k = text[i];\n        if (k === CS) {\n            if (text[i + 1] == CS) {\n                ++i;\n                continue;\n            }\n            out += text.substring(start, i);\n            ++i;\n            while (text[i] != CS && i < text.length) {\n                ++i;\n            }\n            start = i + 1;\n        }\n        else if (k === CE) {\n            if (text[i + 1] == CE) {\n                ++i;\n                continue;\n            }\n            out += text.substring(start, i);\n            start = i + 1;\n        }\n    }\n    if (start == 0)\n        return text;\n    out += text.substring(start);\n    return out;\n}\n","import * as Config from './config';\nimport * as Utils from './utils';\nexport function nextBreak(text, start) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = start;\n    let l = 0;\n    let count = true;\n    while (i < text.length) {\n        const ch = text[i];\n        if (ch == ' ') {\n            while (text[i + 1] == ' ')\n                ++i;\n            return [i, l];\n        }\n        if (ch == '\\n') {\n            return [i, l];\n        }\n        if (ch == CS) {\n            if (text[i + 1] == CS && count) {\n                l += 1;\n                i += 2;\n                continue;\n            }\n            count = !count;\n            ++i;\n            continue;\n        }\n        else if (ch == CE) {\n            if (text[i + 1] == CE) {\n                l += 1;\n                ++i;\n            }\n            i++;\n            continue;\n        }\n        l += (count ? 1 : 0);\n        ++i;\n    }\n    return [i, l];\n}\n// export function wordWrap(text:string, width:number, indent:number=0) {\n// \n//   if (text.length <= width) return text;\n// \n//   let left = width;\n//   const maxWidth = width - indent;\n//   let start = 0;\n//   let output = '';\n// \n//   let i = 0;\n//   while( i < text.length) {\n//     const [j,l] = nextBreak(text, i);\n//     // j = index of space\n//     left -= (l + ((j<text.length) ? 1 : 0));\n//     if (left > 0) {\n//       i = j;\n//     }\n//     else if (left == 0 || left == -1) {\n//       output += text.substring(start, j-1);\n//       if (j < text.length) output += '\\n';\n//       start = i = j;\n//       left = maxWidth;\n//     }\n//     else {  // over (i == space)\n//       output += text.substring(start, i - 1) + '\\n';\n//       start = i;\n//       left = maxWidth;\n//     }\n//   }\n// \n//   if (start == 0) return text;\n// \n//   if (start < text.length) {\n//     output += text.substring(start);\n//   }\n//   return output;\n// }\nexport function splice(text, start, len, add = '') {\n    return text.substring(0, start) + add + text.substring(start + len);\n}\nfunction advanceChars(text, start, count) {\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    let i = start;\n    while (count > 0) {\n        const ch = text[i];\n        if (ch === CS) {\n            ++i;\n            while (text[i] !== CS)\n                ++i;\n            ++i;\n        }\n        else if (ch === CE) {\n            if (text[i + 1] === CE) {\n                --count;\n                ++i;\n            }\n            ++i;\n        }\n        else {\n            --count;\n            ++i;\n        }\n    }\n    return i;\n}\nexport function hyphenate(text, width, start, end, wordWidth, spaceLeftOnLine) {\n    if (wordWidth + 1 > (width * 2)) {\n        throw new Error('Cannot hyphenate - word length > 2 * width');\n    }\n    if ((spaceLeftOnLine < 4) || (spaceLeftOnLine + width < wordWidth)) {\n        text = splice(text, start - 1, 1, '\\n');\n        spaceLeftOnLine = width;\n    }\n    if (spaceLeftOnLine + width > wordWidth) {\n        // one hyphen...\n        const hyphenAt = Math.min(Math.floor(wordWidth / 2), spaceLeftOnLine - 1);\n        const w = advanceChars(text, start, hyphenAt);\n        text = splice(text, w, 0, '-\\n');\n        return [text, end + 2];\n    }\n    if (width >= wordWidth) {\n        return [text, end];\n    }\n    const hyphenAt = Math.min(wordWidth, width - 1);\n    const w = advanceChars(text, start, hyphenAt);\n    text = splice(text, w, 0, '-\\n');\n    return [text, end + 2];\n}\nexport function wordWrap(text, width, indent = 0) {\n    if (!width)\n        throw new Error('Need string and width');\n    if (text.length < width)\n        return text;\n    if (Utils.length(text) < width)\n        return text;\n    if (text.indexOf('\\n') == -1) {\n        return wrapLine(text, width);\n    }\n    const lines = text.split('\\n');\n    const split = lines.map((line, i) => wrapLine(line, width - (i ? indent : 0)));\n    return split.join('\\n');\n}\n// Returns the number of lines, including the newlines already in the text.\n// Puts the output in \"to\" only if we receive a \"to\" -- can make it null and just get a line count.\nfunction wrapLine(text, width) {\n    if (text.length < width)\n        return text;\n    if (Utils.length(text) < width)\n        return text;\n    let spaceLeftOnLine = width;\n    let printString = text;\n    let textLength = printString.length; // do NOT remove color length\n    // Now go through and replace spaces with newlines as needed.\n    // console.log('wordWrap - ', text, width, indent);\n    let i = -1;\n    while (i < textLength) {\n        // wordWidth counts the word width of the next word without color escapes.\n        // w indicates the position of the space or newline or null terminator that terminates the word.\n        let [w, wordWidth] = nextBreak(printString, i + 1);\n        // console.log('- w=%d, width=%d, space=%d', w, wordWidth, spaceLeftOnLine)\n        if (wordWidth > width) {\n            ([printString, w] = hyphenate(printString, width, i + 1, w, wordWidth, spaceLeftOnLine));\n            textLength = printString.length;\n        }\n        else if (wordWidth == spaceLeftOnLine) {\n            const nl = (w < textLength) ? '\\n' : '';\n            printString = splice(printString, w, 1, nl); // [i] = '\\n';\n            spaceLeftOnLine = width;\n        }\n        else if (wordWidth > spaceLeftOnLine || printString[i] === '\\n') {\n            printString = splice(printString, i, 1, '\\n'); // [i] = '\\n';\n            spaceLeftOnLine = width - wordWidth - 1; // line width minus the width of the word we just wrapped and the space\n            //printf(\"\\n\\n%s\", printString);\n        }\n        else {\n            spaceLeftOnLine -= 1 + wordWidth;\n        }\n        i = w; // Advance to the terminator that follows the word.\n    }\n    return printString;\n}\n","import * as Config from './config';\nexport function eachChar(text, fn, fg, bg) {\n    const colors = [];\n    const colorFn = Config.helpers.eachColor;\n    const ctx = {\n        fg: (fg === undefined) ? Config.options.defaultFg : fg,\n        bg: (bg === undefined) ? Config.options.defaultBg : bg,\n    };\n    const CS = Config.options.colorStart;\n    const CE = Config.options.colorEnd;\n    colorFn({ fg, bg });\n    let n = 0;\n    for (let i = 0; i < text.length; ++i) {\n        const ch = text[i];\n        if (ch == CS) {\n            let j = i + 1;\n            while (j < text.length && text[j] != CS) {\n                ++j;\n            }\n            if (j == text.length) {\n                console.warn('Reached end of string while seeking end of color start section.');\n                console.warn('- text:', text);\n                console.warn('- start @:', i);\n                return; // reached end - done (error though)\n            }\n            if (j == i + 1) { // next char\n                ++i; // fall through\n            }\n            else {\n                colors.push([ctx.fg, ctx.bg]);\n                const color = text.substring(i + 1, j);\n                ([ctx.fg, ctx.bg] = color.split('|'));\n                colorFn(ctx);\n                i = j;\n                continue;\n            }\n        }\n        else if (ch == CE) {\n            if (text[i + 1] == CE) {\n                ++i;\n            }\n            else {\n                const c = colors.pop(); // if you pop too many times colors can get weird\n                [ctx.fg, ctx.bg] = c || [null, null];\n                colorFn(ctx);\n                continue;\n            }\n        }\n        fn(ch, n, ctx.fg, ctx.bg);\n        ++n;\n    }\n}\n","import { compile } from './compile';\nimport { eachChar } from './each';\nimport { length, padStart, padEnd, center, capitalize, removeColors } from './utils';\nimport { wordWrap } from './lines';\nimport { addHelper, options } from './config';\nfunction configure(opts = {}) {\n    if (opts.helpers) {\n        Object.entries(opts.helpers).forEach(([name, fn]) => {\n            addHelper(name, fn);\n        });\n    }\n    if (opts.fg) {\n        options.defaultFg = opts.fg;\n    }\n    if (opts.bg) {\n        options.defaultBg = opts.bg;\n    }\n    if (opts.colorStart) {\n        options.colorStart = opts.colorStart;\n    }\n    if (opts.colorEnd) {\n        options.colorEnd = opts.colorEnd;\n    }\n    if (opts.field) {\n        options.field = opts.field;\n    }\n}\nexport { compile, eachChar, length, padStart, padEnd, center, capitalize, removeColors, wordWrap, configure, addHelper, };\n"],"names":["options","colorStart","colorEnd","field","defaultFg","defaultBg","helpers","eachColor","addHelper","name","fn","textSegment","value","length","text","len","CS","Config.options","CE","i","ch","indexOf","nextBreak","start","l","count","splice","add","substring","advanceChars","hyphenate","width","end","wordWidth","spaceLeftOnLine","Error","Math","min","floor","wrapLine","Utils.length","printString","textLength","w","template","F","console","log","sections","split","map","part","pattern","data","exec","helper","base","format","result","args","source","obj","undefined","fieldValue","Config.helpers","helperValue","endsWith","Number","parseInt","padEnd","padStart","stringFormat","wantSign","includes","left","intFormat","fixed","parseFloat","toFixed","floatFormat","makeVariable","f","join","fg","bg","colors","colorFn","ctx","n","j","warn","push","color","c","pop","pad","colorLen","rawLen","padLen","toUpperCase","out","k","indent","line","opts","Object","entries","forEach"],"mappings":"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"}